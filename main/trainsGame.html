<!DOCTYPE html>
<html lang="ja">

<head>
    <title>ATCIC</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<style>
    

    :root {
        --background-color: #000000;
        --text-color: #ffffff;
    }

    ::selection {
        color: var(--background-color);
        background: var(--text-color);
    }

    body.light {
        --background-color: #ffffff;
        --text-color: #000000;
    }

    body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        background-color: var(--background-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: 'Space Mono', monospace;
        user-select: none;       
    }

    .consoleOut-container {
        font-size: small;
        position: relative;
        line-height: 80%;
        display: block;
        white-space: pre;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    span.conOut-spn {
        /* This took me two hours to figure out!! Fuck!! */
        display: inline-block;
    }

</style>

<body>
    <!-- nothing Here -->
</body>

<script>

    /**
     *  *********************
     *    U T I L I T I E S
     *  *********************
    */

    /*====== Check if the platform is mobile. */
    function isMobileDevice() {
        return /Mobi|Android/i.test(navigator.userAgent);
    }

    function appendChildAtIndex(parent, child, index) {
        if (index >= 0 && index <= parent.children.length) {
            if (index === parent.children.length) {
                parent.appendChild(child);
            } else {
                parent.insertBefore(child, parent.children[index]);
            }
        } else {
            console.log('Invalid index');
        }
    }

    function rand2D(seed1, seed2) {
        let t = seed1 * 1917 + seed2 * 5491;
        t = Math.abs((t * t) % 2147483647);
        return t;
    }

    function asyncSleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function ms() {
        return performance.now();
    }

    function getDecimalPart(number) {
        let integerPart = Math.trunc(number);
        let decimalPart = number - integerPart;
        return Math.abs(decimalPart);
    }

    function mapToHSL(value, min, max) {
        let normalizedValue = (value - min) / (max - min);
        normalizedValue = getDecimalPart(normalizedValue);
        let hue = normalizedValue * 360;
        return `hsl(${hue}, 100%, 50%)`;
    }

    function drawLine(y0, x0, y1, x1, plotFunc) {
        let dx = Math.abs(x1 - x0);
        let dy = Math.abs(y1 - y0);
        let sx = (x0 < x1) ? 1 : -1;
        let sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;
        while (true) {
            plotFunc(x0, y0); 
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                err += dx;
                y0 += sy;
            }
        }
    }

    const keysPressed = {};
    document.addEventListener('keydown', (event) => { keysPressed[event.key] = true; });
    document.addEventListener('keyup', (event) => { keysPressed[event.key] = false; });
    function isKeyDown(key) { return keysPressed[key] || false; }
    function isAnyKeyDown() {
        for (let key in keysPressed) {
            if (keysPressed[key]) {
                return true;
            }
        }
        return false;
    }
    /*=== The Perlin Noise Class. Code generated by Sonnet. */
    class PerlinNoise {
        constructor() {
            // Permutation table
            this.p = new Array(256);
            for(let i = 0; i < 256; i++) {
                this.p[i] = i;
            }

            // Shuffle permutation table
            for(let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
            }

            // Extend the permutation table to avoid overflow
            this.p = [...this.p, ...this.p];
        }

        fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        lerp(t, a, b) {
            return a + t * (b - a);
        }

        grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        noise(x, y = 0, z = 0) {
            // Find unit cube that contains point
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;

            // Find relative x, y, z of point in cube
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);

            // Compute fade curves
            const u = this.fade(x);
            const v = this.fade(y);
            const w = this.fade(z);

            // Hash coordinates of cube corners
            const A = this.p[X] + Y;
            const AA = this.p[A] + Z;
            const AB = this.p[A + 1] + Z;
            const B = this.p[X + 1] + Y;
            const BA = this.p[B] + Z;
            const BB = this.p[B + 1] + Z;

            // Add blended results from corners of cube
            return this.lerp(w,
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA], x, y, z),
                        this.grad(this.p[BA], x-1, y, z)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB], x, y-1, z),
                        this.grad(this.p[BB], x-1, y-1, z)
                    )
                ),
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA+1], x, y, z-1),
                        this.grad(this.p[BA+1], x-1, y, z-1)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB+1], x, y-1, z-1),
                        this.grad(this.p[BB+1], x-1, y-1, z-1)
                    )
                )
            );
        }
    }

    /**
     *  ***************
     *    C o n O u t
     *  ***************
    */
    /**
     *    The ConsoleOut Class. Aimed to re-create the one I've written in C++
     *    with HTML capabilities. */
    class ConsoleOut {
        constructor(width, height, elementID) {
            this.defaultChar = ' ';
            this.w = width;
            this.h = height;
            this.conDiv = document.getElementById(elementID);
            this.conDiv.replaceChildren();
            this.lines = [];

            for (let i = 0; i < height; i++) {
                let newLineDiv = document.createElement('div');
                let firstSpan = document.createElement('span');
                let spaces = this.defaultChar.repeat(width);

                newLineDiv.id = 'Line ' + String(i);
                firstSpan.textContent = spaces;
                firstSpan.className = 'conOut-spn';
                newLineDiv.appendChild(firstSpan);

                this.conDiv.appendChild(newLineDiv);
                this.lines[i] = {
                    div: newLineDiv,
                    sections: [{ span: firstSpan, Xpoz: 0, length: this.w }]
                };
            }
        }

        __truncateSpan(sections, index, XCoord, trunLen) {
            const section = sections[index];
            const sectionStart = section.Xpoz;
            const sectionEnd = sectionStart + section.length;
            const truncStart = XCoord;
            const truncEnd = XCoord + trunLen;
            const parentDiv = section.span.parentElement;

            // Calculate overlap
            const overlapStart = Math.max(sectionStart, truncStart);
            const overlapEnd = Math.min(sectionEnd, truncEnd);
            const overlapLength = overlapEnd - overlapStart;

            // No overlap
            if (overlapLength <= 0) {
                return -1;
            }

            // Complete overlap: Remove the entire section
            if (overlapStart <= sectionStart && overlapEnd >= sectionEnd) {
                section.span.remove();
                sections.splice(index, 1);
                return 1;
            }

            // Overlap at the start: Truncate the beginning of the section
            if (overlapStart <= sectionStart) {
                const newStart = overlapEnd;
                const newLength = sectionEnd - newStart;
                section.Xpoz = newStart;
                section.length = newLength;
                section.span.textContent = section.span.textContent.slice(-newLength);
                return 2;
            }

            // Overlap at the end: Truncate the end of the section
            if (overlapEnd >= sectionEnd) {
                const newLength = overlapStart - sectionStart;
                section.length = newLength;
                section.span.textContent = section.span.textContent.substring(0, newLength);
                return 3;
            }

            // Overlap in the middle: Split the section into two
            const leftSpan = section.span.cloneNode(true);
            const rightSpan = section.span.cloneNode(true);

            const leftTextLength = overlapStart - sectionStart;
            const rightTextStart = overlapEnd - sectionStart;
            const rightTextLength = sectionEnd - overlapEnd;

            leftSpan.textContent = section.span.textContent.substring(0, leftTextLength);
            rightSpan.textContent = section.span.textContent.substring(rightTextStart);

            const leftSection = {
                span: leftSpan,
                Xpoz: sectionStart,
                length: leftTextLength
            };

            const rightSection = {
                span: rightSpan,
                Xpoz: overlapEnd,
                length: rightTextLength
            };

            // Replace the original section with the two new sections
            sections.splice(index, 1, leftSection, rightSection);

            // Update the DOM
            section.span.remove();
            parentDiv.insertBefore(rightSpan, parentDiv.children[index]);
            parentDiv.insertBefore(leftSpan, rightSpan);

            return 4;
        }

        _makeWay(YCoord, XCoord, emptyLength) {
            if (XCoord + emptyLength > this.w || XCoord < 0) { return -1; }
            let line = this.lines[YCoord];

            for (let i = line.sections.length - 1; i >= 0; i--) {
                this.__truncateSpan(line.sections, i, XCoord, emptyLength);
            }
            return 0;
        }

        _fitSpan(YCoord, XCoord, pendingSpan) {
            let line = this.lines[YCoord];
            let parentDiv = line.div;
            let spanLength = pendingSpan.textContent.length;
            pendingSpan.className = 'conOut-spn';

            let inserted = false;
            for (let i = 0; i < line.sections.length; i++) {
                let currentSection = line.sections[i];
                if (XCoord < currentSection.Xpoz) {
                    line.sections.splice(i, 0, {
                        span: pendingSpan,
                        Xpoz: XCoord,
                        length: spanLength
                    });
                    parentDiv.insertBefore(pendingSpan, currentSection.span);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                line.sections.push({
                    span: pendingSpan,
                    Xpoz: XCoord,
                    length: spanLength
                });
                parentDiv.appendChild(pendingSpan);
            }

            return 0;
        }

        _getConcernedSpanInfo(line, XCoord, length) {
            let info = [];
            const endCoord = XCoord + length;

            for (let section of line.sections) {
                const sectionEnd = section.Xpoz + section.length;
                if (XCoord >= sectionEnd || endCoord <= section.Xpoz) { continue; }
                const relStart = Math.max(0, XCoord - section.Xpoz);
                const relEnd = Math.min(section.length, endCoord - section.Xpoz);
                info.push({
                    span: section.span,
                    relStart: relStart,
                    relEnd: relEnd
                });
            }
            return info;
        }

        getRawText(YCoord, XCoord, length) {
            if (YCoord >= this.h || YCoord < 0 || XCoord < 0 || XCoord + length > this.w) { return ''; }
            let line = this.lines[YCoord];
            let concernedInfo = this._getConcernedSpanInfo(line, XCoord, length);
            let text = '';

            for (let currentInfo of concernedInfo) {
                let currentText = currentInfo.span.textContent;
                text += currentText.substring(currentInfo.relStart, currentInfo.relEnd);
            }
            return text;
        }

        setRawText(YCoord, XCoord, text) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            let line = this.lines[YCoord];
            let concernedInfo = this._getConcernedSpanInfo(line, XCoord, text.length);
            let i = 0;

            for (let currentInfo of concernedInfo) {
                let oriText = currentInfo.span.textContent;
                let textPart1 = oriText.substring(0, currentInfo.relStart);
                let newText = text.substring(i, i + currentInfo.relEnd - currentInfo.relStart);
                let textPart3 = oriText.substring(currentInfo.relEnd);
                currentInfo.span.textContent = textPart1 + newText + textPart3;
                i += currentInfo.relEnd - currentInfo.relStart;
            }
            return 0;
        }

        setRawTextMid(YCoord, XCoordMid, text) {
            this.setRawText(YCoord, XCoordMid - Math.floor(text.length / 2), text);
        }

        setStyle(YCoord, XCoord, length, emptyStyleSpan) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            let text = this.getRawText(YCoord, XCoord, length);
            let dupSpan = emptyStyleSpan.cloneNode(true);
            dupSpan.textContent = text;
            this._makeWay(YCoord, XCoord, length);
            this._fitSpan(YCoord, XCoord, dupSpan);
            return 0;
        }

        clearLineText(YCoord) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            this.setRawText(YCoord, 0, this.defaultChar.repeat(this.w));
            return 0;
        }

        clearLineStyle(YCoord) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            let sp = document.createElement('span');
            sp.className = 'conOut-spn';
            this.setStyle(YCoord, 0, this.w, sp);
            return 0;
        }

        clsText() {
            for (let i = 0; i < this.h; i++) {
                this.clearLineText(i);
            }
            return 0;
        }

        clsStyle() {
            for (let i = 0; i < this.h; i++) {
                this.clearLineStyle(i);
            }
            return 0;
        }
    }


    /**
     *  ***********
     *    G A M E
     *  ***********
    */
    class Game {
        static Cars = {
            'Series 201' : {
                'name'          : '201-Kei',
                'maxPower'      : 625000.0,   // Watts
                'maxForce'      : 40000.0,    // Newtons
                'maxBreakForce' : 40000.0,    // Newtons
                'weight'        : 35000.0,    // Kilograms
                'dragCoef'      : 55.0,       // N / (m/s)^2
                'fricCoef'      : 0.10,       // N / kg
                'centerOfMass'  : 1.0         // Meters (Height)
            }
        }

        static Track = class Track {
            constructor() {
                this.myPerlin = new PerlinNoise();
                this.perlinY = Math.random();
            }
        }

        static Train = class Train {
            constructor(car, carCount, track) {

            }
        }

        constructor() {
            this.pFPS = 120;      //  Physics calculations per second.
            this.pFPRender = 4;   //  Physics calculations per render.
            this.pPeriodMS = 1000 / this.pFPS; // Period length of Phy-frame.
            this.beginMS = ms();
            this.lastPFMS = this.beginMS;
        }

        physicsLoop() {

        }
    }

    /**
     *  *********************
     *    T E S T I N G
     *  *********************
    */
    async function testDisplay(conOut) {
        let rawTexts = [' nothing', '.NOTHING'];
        let hintTexts = ['[Shift] + [SpaceBar] :  Next',
                         '                            '];
        let rI = 1;
        let showHint = 1;
        let blinkLastMS = ms();
        let hintI = 0;
        setTimeout(() => { showHint = 0; 
            conOut.setRawTextMid(HEIGHT - 10, WIDTH / 2, hintTexts[1]) }, 10000);
        outerLoop:
        for (let i = 0; i < HEIGHT; i = (i + 1) % HEIGHT) {
            for (let j = -10; j < WIDTH; j ++) {
                conOut.setRawText(i, j, rawTexts[rI]);   
                if (showHint) { 
                    if (blinkLastMS < ms() - 750) { 
                        blinkLastMS = ms();
                        conOut.setRawTextMid(HEIGHT - 10, WIDTH / 2, hintTexts[hintI]);
                        hintI = (hintI + 1) % 2;
                    }
                }
                await asyncSleep(1000 / 20);
                if (testBreakOut) { break outerLoop; }
            }
            if (i == HEIGHT - 1) { rI = (rI + 1) % 2;}
        }
        testBreakOut = 0;
        conOut.clsStyle();
        conOut.clsText();
        return 1;
    }

    async function testPerlin(conOut) {
        let p = new PerlinNoise();
        let DEPTH = 7;
        let xCenter = 0.0; let xZoom = 1.0;
        let yCenter = 0.0;
        let zCenter = 0.0; let zZoom = 1.0;
        let outZoom = 1.0;
        let sp = document.createElement('span');
        let dismissedHint = 0;
        var doDepthDisplay = false;
        let PKeyLast = isKeyDown('p');
        sp.style.backgroundColor = '#ffffff';
        sp.style.color = '#000000';
        function printXYZData() {
            conOut.setRawText(HEIGHT - 2, 4, `Z: ${zCenter.toFixed(3)}`);
            conOut.setRawText(HEIGHT - 3, 4, `Y: ${yCenter.toFixed(3)}`);
            conOut.setRawText(HEIGHT - 4, 4, `X: ${xCenter.toFixed(3)}`);
        }
        printXYZData();
        function drawPerlin(depth, plotFunc) {
            let points = [];
            for (let w = 0; w < WIDTH; w ++) {
                let x = xCenter + (w - WIDTH / 2) / WIDTH * xZoom;
                let z = zCenter + (depth - DEPTH / 2) / DEPTH * zZoom;
                let out = p.noise(x, yCenter, z) * outZoom * (HEIGHT / 2) + HEIGHT / 2;
                points.splice(0, 0, { Y: Math.floor(out), X: w });
            }
            for (let i = 0; i < points.length - 1; i ++) {
                drawLine(points[i].Y, points[i].X, points[i + 1].Y, points[i + 1].X, plotFunc);
            }
        }
        function charPlotFunc(X, Y) { conOut.setRawText(Y, X, '#'); }
        drawPerlin(DEPTH / 2, charPlotFunc);
        await asyncSleep(1000);
        let doDraw = 0;
        function pCheck(event) {
            if (event.key == 'p') {
                doDepthDisplay = !doDepthDisplay; conOut.clsStyle();
            }
        }
        document.addEventListener('keydown', pCheck);
        while (!testBreakOut) {
            doDraw = 0;
            if (isAnyKeyDown()) { doDraw = 1; }
            if (isKeyDown('m')) { dismissedHint = 1; }
            if (isKeyDown('a')) { xCenter -= 0.01 * xZoom; }
            if (isKeyDown('d')) { xCenter += 0.01 * xZoom;  }
            if (isKeyDown('s')) { zCenter -= 0.01 * zZoom;  }
            if (isKeyDown('w')) { zCenter += 0.01 * zZoom;  }
            if (isKeyDown('q')) { yCenter -= 0.01;  }
            if (isKeyDown('e')) { yCenter += 0.01;  }
            if (isKeyDown('h')) { xZoom /= 1.01; }
            if (isKeyDown('k')) { xZoom *= 1.01; }
            if (isKeyDown('u')) { zZoom /= 1.01; }
            if (isKeyDown('j')) { zZoom *= 1.01; }
            if (isKeyDown('y')) { outZoom /= 1.01; }
            if (isKeyDown('i')) { outZoom *= 1.01; }
            if (doDraw) {
                conOut.clsText();
                if (!dismissedHint) {
                    conOut.setRawText(HEIGHT - 4, WIDTH / 2 + 4, `WASDQE / UHJKYI / M / P / L`);
                }
                
                if (doDepthDisplay) {
                    conOut.clsStyle();
                    let sp = document.createElement('span');
                    for (let i = 0; i < DEPTH; i ++) {
                        sp.style.backgroundColor = mapToHSL(zCenter + (i - DEPTH / 2) / DEPTH * zZoom, -1, 1);
                        function stylePlotFunc(X, Y) { conOut.setStyle(Y, X, 1, sp); }
                        drawPerlin(i, stylePlotFunc);
                    }
                }
                
                drawPerlin(DEPTH / 2, charPlotFunc);
                printXYZData();
            }
            await asyncSleep(1000 / 60);
        }
        testBreakOut = 0;
        conOut.clsText();
        conOut.clsStyle();
        document.removeEventListener('keydown', pCheck);
        return 0;
    }
    
    document.body.innerHTML = '<div class="consoleOut-container" id="conOut-div0"></div>';
    /* V4refT5f's effort... Appreciate it! O_o
    document.body.innerHTML = '<div class="consoleOut-container" id="conOut-div0"></div>';
    document.addEventListener('keydown', function (event) {
        if (event.key == 'l') {
            document.getElementsByTagName('body')[0].classList.toggle('light-switch');
        }
        if (event.key == ' ' && event.shiftKey) {
            testBreakOut = 1;
        }
    })
    */

    document.addEventListener('keydown', function (event) {
        if ((event.key === 'l' || event.key === 'L')) {
            document.body.classList.toggle('light');
            if (document.body.classList.contains('light')) {
                window.lightMode = 'light-mode';
            }
            else {
                window.lightMode = 'dark-mode';
            }
            localStorage.setItem('window.lightMode', window.lightMode);
        }
        if (event.key == ' ' && event.shiftKey) {
            testBreakOut = 1;
        }
    });

    (function () {
        if (localStorage.getItem("window.lightMode") == "light-mode") {
            document.body.classList.add('light');
        }
    })();


    const WIDTH = 64;
    const HEIGHT = 64;
    const myConOut = new ConsoleOut(WIDTH, HEIGHT, 'conOut-div0');
    var testBreakOut = 0;

    if (isMobileDevice()) { 
        myConOut.setRawTextMid(Math.floor(HEIGHT / 2), Math.floor(WIDTH / 2), 'No Train For YiDong'); 
    } else {
        async function doTests() {
            await testDisplay(myConOut);
            await testPerlin(myConOut);
            return 0;
        }
        doTests();
    }


</script>

</html>