<!DOCTYPE html>
<html lang="ja">

<head>
    <title>ATCIC</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<style>
    

    :root {
        --background-color: #151515;
        --text-color: #f7f7f7;
    }

    ::selection {
        color: var(--background-color);
        background: var(--text-color);
    }

    body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        background-color: var(--background-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: 'Space Mono', monospace;
        user-select: none;       
    }

    .consoleOut-container {
        font-size: large;
        position: relative;
        line-height: 80%;
        display: block;
        white-space: pre;
        overflow: hidden;
        text-overflow: ellipsis;
        z-index: 1;
    }

    span {
        /* This took me two hours to figure out!! Fuck!! */
        display: inline-block;
        margin-top: -10px;
        margin-bottom: -10px;
    }

</style>

<body>
    <!-- nothing Here -->
</body>

<script>
    /*====== Check if the platform is mobile. */
    function isMobileDevice() {
        return /Mobi|Android/i.test(navigator.userAgent);
    }

    function appendChildAtIndex(parent, child, index) {
        if (index >= 0 && index <= parent.children.length) {
            if (index === parent.children.length) {
                parent.appendChild(child);
            } else {
                parent.insertBefore(child, parent.children[index]);
               }
        } else {
            console.log('Invalid index');
        }
    }


    /*=== The Perlin Noise Class. Code generated by Sonnet. */
    class PerlinNoise {
        constructor() {
            // Permutation table
            this.p = new Array(256);
            for(let i = 0; i < 256; i++) {
                this.p[i] = i;
            }

            // Shuffle permutation table
            for(let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
            }

            // Extend the permutation table to avoid overflow
            this.p = [...this.p, ...this.p];
        }

        fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        lerp(t, a, b) {
            return a + t * (b - a);
        }

        grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        noise(x, y = 0, z = 0) {
            // Find unit cube that contains point
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;

            // Find relative x, y, z of point in cube
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);

            // Compute fade curves
            const u = this.fade(x);
            const v = this.fade(y);
            const w = this.fade(z);

            // Hash coordinates of cube corners
            const A = this.p[X] + Y;
            const AA = this.p[A] + Z;
            const AB = this.p[A + 1] + Z;
            const B = this.p[X + 1] + Y;
            const BA = this.p[B] + Z;
            const BB = this.p[B + 1] + Z;

            // Add blended results from corners of cube
            return this.lerp(w,
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA], x, y, z),
                        this.grad(this.p[BA], x-1, y, z)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB], x, y-1, z),
                        this.grad(this.p[BB], x-1, y-1, z)
                    )
                ),
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA+1], x, y, z-1),
                        this.grad(this.p[BA+1], x-1, y, z-1)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB+1], x, y-1, z-1),
                        this.grad(this.p[BB+1], x-1, y-1, z-1)
                    )
                )
            );
        }
    }

    /**
     *    The ConsoleOut Class. Aimed to re-create the one I've written in C++
     *    with HTML capabilities. */
    class ConsoleOut {
        constructor(width, height, elementID) {
            this.defaultChar = ' ';
            this.w = width;
            this.h = height;
            this.conDiv = document.getElementById(elementID);
            this.conDiv.replaceChildren();
            this.lines = []; 

            for (let i = 0; i < height; i ++) {
                let newLineDiv = document.createElement('div');
                let firstSpan = document.createElement('span');
                let spaces = this.defaultChar.repeat(width);

                newLineDiv.id = 'Line ' + String(i);
                firstSpan.textContent = spaces;
                firstSpan.className = 'conOut-spn';
                newLineDiv.appendChild(firstSpan);

                this.conDiv.appendChild(newLineDiv);
                this.lines[i] = { div: newLineDiv, 
                                  sections: [ { span: firstSpan, Xpoz: 0, length: this.w } ]};
            }
        }

        __truncateSpan(sections, index, XCoord, trunLen) {
            let section = sections[index];
            let oldEndingPoz = section.Xpoz + section.length;
            let oldText = section.span.textContent;
            let parentDiv = section.span.parentElement;

            if (XCoord + trunLen <=  section.Xpoz) { return -1; }
            if (XCoord           >=  section.Xpoz + section.length) { return -1; }
            if (XCoord           <= section.Xpoz) {
                if (XCoord + trunLen >= section.Xpoz + section.length) {
                    sections[index].span.remove();
                    sections.splice(index, 1);
                    return 1; 
                } else {
                    sections[index].Xpoz   = XCoord + trunLen;
                    sections[index].length = oldEndingPoz - sections[index].Xpoz;
                    sections[index].span.textContent = oldText.substring(section.length - sections[index].length);
                    return 2;
                }
            }
            if (XCoord           > section.Xpoz) {
                if (XCoord + trunLen >= section.Xpoz + section.length) {
                    sections[index].length = oldEndingPoz - XCoord;
                    sections[index].span.textContent = oldText.substring(0, sections[index].length);
                    return 3;
                } else {
                    let splSpan1 = sections[index].span.cloneNode(true);
                    let splSpan2 = sections[index].span.cloneNode(true);
                    splSpan1.textContent = oldText.substring(0, XCoord - section.Xpoz);
                    splSpan2.textContent = oldText.substring(section.length - (oldEndingPoz - (XCoord + trunLen)));
                    sections[index].span.remove();
                    sections.splice(index, 1);
                    sections.splice(index,     0, 
                                    { span: splSpan1, Xpoz: section.Xpoz, length: XCoord - section.Xpoz});
                    sections.splice(index + 1, 0, 
                                    { span: splSpan2, Xpoz: XCoord + trunLen, length: oldEndingPoz - (XCoord + trunLen)});
                    appendChildAtIndex(parentDiv, splSpan1, index);
                    appendChildAtIndex(parentDiv, splSpan2, index + 1);
                    return 4;
                }
            }
        }

        /**
         *   This method splits and / or removes spans 
         *   to make way for the newcoming span in a line.  
         *   Like:  <div><span></span></div>  ->  <div><span></span><span></span></div> 
         *   There's no hierarchy between spans.*/
        _makeWay(YCoord, XCoord, emptyLength) {
            if (XCoord + emptyLength > this.width) { return -1; }
            let line = this.lines[YCoord];

            for (let i = 0; i < line.sections.length; i ++) {
                this.__truncateSpan(line.sections, i, XCoord, emptyLength);
            }
            return 0;
        }

        _fitSpan(YCoord, XCoord, pendingSpan) {
            let line = this.lines[YCoord];
            let parentDiv = line.div;
            let spanLength = pendingSpan.textContent.length;
            pendingSpan.className = 'conOut-spn';

            for (let i = 0; i < line.sections.length; i++) {
                let currentSection = line.sections[i];
                let currentEnd = currentSection.Xpoz + currentSection.length;
                
                if (XCoord < currentEnd) continue;

                let gapLength;
                if (i === line.sections.length - 1) {
                    gapLength = this.width - currentEnd;
                } else {
                    gapLength = line.sections[i + 1].Xpoz - currentEnd;
                }

                if (spanLength <= gapLength) {
                    line.sections.splice(i + 1, 0, {
                        span: pendingSpan,
                        Xpoz: currentEnd,
                        length: gapLength
                    });
                    appendChildAtIndex(parentDiv, pendingSpan, i + 1);
                    return 0;
                }
            }
            return 0;
        }

        _getConcernedSpanInfo(line, XCoord, length) {
            let info = [];
            const endCoord = XCoord + length;

            for (let section of line.sections) {
                const sectionEnd = section.Xpoz + section.length;
                if (XCoord >= sectionEnd || endCoord <= section.Xpoz) { continue; }
                const relStart = Math.max(0, XCoord - section.Xpoz);
                const relEnd = Math.min(section.length, endCoord - section.Xpoz);
                info.push({
                    span: section.span,
                    relStart: relStart,
                    relEnd: relEnd
                });
            }
            return info;
        }

        getRawText(YCoord, XCoord, length) {
            let line = this.lines[YCoord];
            let concernedInfo = this._getConcernedSpanInfo(line, XCoord, length);
            let text = '';

            for (let currentInfo of concernedInfo) {
                let currentText = currentInfo.span.textContent;
                text += currentText.substring(currentInfo.relStart, currentInfo.relEnd);
            }
            return text;
        }

        setRawText(YCoord, XCoord, text) {
            let line = this.lines[YCoord];
            let concernedInfo = this._getConcernedSpanInfo(line, XCoord, text.length);
            let i = 0;

            for (let currentInfo of concernedInfo) {
                let oriText = currentInfo.span.textContent;
                let textPart1 = oriText.substring(0, currentInfo.relStart);
                let newText   = text.substring(i, i + currentInfo.relEnd - currentInfo.relStart);
                let textPart3 = oriText.substring(currentInfo.relEnd, oriText.length);
                currentInfo.span.textContent = textPart1 + newText + textPart3;
                i += currentInfo.relEnd - currentInfo.relStart;
            }
            return 0;
        }

        setStyle(YCoord, XCoord, length, emptyStyleSpan) {
            let text = this.getRawText(YCoord, XCoord, length);
            emptyStyleSpan.textContent = text;
            this._makeWay(YCoord, XCoord, length);
            this._fitSpan(YCoord, XCoord, emptyStyleSpan);
            return 0;
        }
    }

    document.body.innerHTML = '<div class="consoleOut-container" id="conOut-div0"></div>';
    const myConOut = new ConsoleOut(45, 45, 'conOut-div0');

    let sp = document.createElement('span');
    sp.style.backgroundColor = "#0000ff";
    sp.style.color = "#ff0000";
    myConOut.setRawText(6, 34, 'NONONO');
    myConOut.setStyle(6, 32, 10, sp);

</script>

</html>