<!DOCTYPE html>
<html lang="ja">

<!-- 
    This is the HTML Header.
    It contains the metadata of the page.
    The metadata includes the character encoding, the viewport, 
    and the title of the page.
    The metadata is used by the browser to render the page correctly.
 -->
<head>
    <title>ATCIC</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<style>
    :root {
        --background-color: #151515;
        --text-color: #f7f7f7;
    }

    ::selection {
        color: var(--background-color);
        background: var(--text-color);
    }

    body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        background-color: var(--background-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: 'Space Mono', monospace;
        user-select: none;        
    }

    .consoleOut-container {
        font-size: large;
        white-space: nowrap;
        position: absolute;
        line-height: 80%;
    }

</style>

<body>
    <!-- nothing Here -->
</body>

<script>
    /*====== Check if the platform is mobile. */
    function isMobileDevice() {
        return /Mobi|Android/i.test(navigator.userAgent);
    }

    /*=== The Perlin Noise Class. Code generated by Sonnet. */
    class PerlinNoise {
        constructor() {
            // Permutation table
            this.p = new Array(256);
            for(let i = 0; i < 256; i++) {
                this.p[i] = i;
            }

            // Shuffle permutation table
            for(let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
            }

            // Extend the permutation table to avoid overflow
            this.p = [...this.p, ...this.p];
        }

        fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        lerp(t, a, b) {
            return a + t * (b - a);
        }

        grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        noise(x, y = 0, z = 0) {
            // Find unit cube that contains point
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;

            // Find relative x, y, z of point in cube
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);

            // Compute fade curves
            const u = this.fade(x);
            const v = this.fade(y);
            const w = this.fade(z);

            // Hash coordinates of cube corners
            const A = this.p[X] + Y;
            const AA = this.p[A] + Z;
            const AB = this.p[A + 1] + Z;
            const B = this.p[X + 1] + Y;
            const BA = this.p[B] + Z;
            const BB = this.p[B + 1] + Z;

            // Add blended results from corners of cube
            return this.lerp(w,
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA], x, y, z),
                        this.grad(this.p[BA], x-1, y, z)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB], x, y-1, z),
                        this.grad(this.p[BB], x-1, y-1, z)
                    )
                ),
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA+1], x, y, z-1),
                        this.grad(this.p[BA+1], x-1, y, z-1)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB+1], x, y-1, z-1),
                        this.grad(this.p[BB+1], x-1, y-1, z-1)
                    )
                )
            );
        }
    }

    /**
     *    The ConsoleOut Class. Aimed to re-create the one I've written in C++
     *    with HTML capabilities. */
    class ConsoleOut {
        constructor(width, height, elementID) {
            this.defaultChar = '6';
            this.w = width;
            this.h = height;
            this.conDiv = document.getElementById(elementID);
            this.conDiv.replaceChildren();
            this.lines = []; 
            this.spanClassCounter = 1;

            for (let i = 0; i < height; i ++) {
                let newLineDiv = document.createElement('div');
                let firstSpan = document.createElement('span');
                let spaces = this.defaultChar.repeat(width);

                newLineDiv.id = 'Line ' + String(i);
                firstSpan.textContent = spaces;
                firstSpan.className = 'conOut-spn-default';
                newLineDiv.appendChild(firstSpan);

                this.conDiv.appendChild(newLineDiv);
                this.lines[i] = { div: newLineDiv, 
                                  sections: [ { span: firstSpan, Xpoz: 0, length: this.w } ]};
            }
        }

        __truncateSpan(sections, index, XCoord, trunLen) {
            let section = sections[index];
            let oldEndingPoz = section.Xpoz + section.length;
            let oldText = section.span.textContent;
            let parentDiv = section.span.parentElement;

            if (XCoord + trunLen <=  section.Xpoz) { return -1; }
            if (XCoord           >=  section.Xpoz + section.length) { return -1; }
            if (XCoord           <= section.Xpoz) {
                if (XCoord + trunLen >= section.Xpoz + section.length) {
                    sections[index].span.remove();
                    sections.splice(index, 1);
                    return 1; 
                } else {
                    sections[index].Xpoz   = XCoord + trunLen;
                    sections[index].length = oldEndingPoz - sections[index].Xpoz;
                    sections[index].span.textContent = oldText.substring(section.length - sections[index].length);
                    return 2;
                }
            }
            if (XCoord           > section.Xpoz) {
                if (XCoord + trunLen >= section.Xpoz + section.length) {
                    sections[index].length = oldEndingPoz - XCoord;
                    sections[index].span.textContent = oldText.substring(0, sections[index].length);
                    return 3;
                } else {
                    let splSpan1 = sections[index].span.cloneNode(true);
                    let splSpan2 = sections[index].span.cloneNode(true);
                    splSpan1.textContent = oldText.substring(0, XCoord - section.Xpoz);
                    splSpan2.textContent = oldText.substring(section.length - (oldEndingPoz - (XCoord + trunLen)));
                    sections[index].span.remove();
                    sections.splice(index, 1);
                    sections.splice(index,     0, 
                                    { span: splSpan1, Xpoz: section.Xpoz, length: XCoord - section.Xpoz});
                    sections.splice(index + 1, 0, 
                                    { span: splSpan2, Xpoz: XCoord + trunLen, length: oldEndingPoz - (XCoord + trunLen)});

                    function appendChildAtIndex(parent, child, index) {
                        if (index >= 0 && index <= parent.children.length) {
                            if (index === parent.children.length) {
                                parent.appendChild(child);
                            } else {
                                parent.insertBefore(child, parent.children[index]);
                            }
                        } else {
                            console.log('Invalid index');
                        }
                    }

                    appendChildAtIndex(parentDiv, splSpan1, index);
                    appendChildAtIndex(parentDiv, splSpan2, index + 1);
                    return 4;
                }
            }
        }

        /**
         *   This method splits and / or removes spans 
         *   to make way for the newcoming span in a line.  
         *   Like:  <div><span></span></div>  ->  <div><span></span><span></span></div> 
         *   There's no hierarchy between spans.*/
        _makeWay(YCoord, XCoord, emptyLength) {
            if (XCoord + emptyLength > this.width) { return -1; }
            let line = this.lines[YCoord];
            for (let i = 0; i < line.sections.length; i ++) {
                this.__truncateSpan(line.sections, i, XCoord, emptyLength);
            }
            return 0;
        }

        _fitSpan(YCoord, XCoord, pendingSpan) {
            let line = this.lines[YCoord];
            for (let i = 0; i < line.sections.length - 1; i ++) {
                let gapLen = line.sections[i + 1].Xpoz - (line.sections[i].Xpoz + line.sections[i].length);
                if (pendingSpan.textContent.length <= gapLen) {
                    if (XCoord >= line.sections[i + 1].Xpoz) {
                        line.sections.splice(i + 1, 0, 
                                    { span: pendingSpan, Xpoz: line.sections[i].Xpoz + line.sections[i].length, length: gapLen});
                        break;
                    }
                }
            }
            return 0;
        }

        
    }

    document.body.innerHTML = '<div class="consoleOut-container" id="conOut-div0"></div>';
    const myConOut = new ConsoleOut(45, 45, 'conOut-div0');

</script>

</html>