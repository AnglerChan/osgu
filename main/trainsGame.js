
    /**
     *  *********************
     *    U T I L I T I E S
     *  *********************
    */

    /*====== Check if the platform is mobile. */
    function isMobileDevice() {
        return /Mobi|Android/i.test(navigator.userAgent);
    }

    function appendChildAtIndex(parent, child, index) {
        if (index >= 0 && index <= parent.children.length) {
            if (index === parent.children.length) {
                parent.appendChild(child);
            } else {
                parent.insertBefore(child, parent.children[index]);
            }
        } else {
            console.log('Invalid index');
        }
    }

    function rand2D(seed1, seed2) {
        let t = seed1 * 1917 + seed2 * 5491;
        t = Math.abs((t * t) % 2147483647);
        return t;
    }

    function asyncSleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function ms() {
        return performance.now();
    }

    function getDecimalPart(number) {
        let integerPart = Math.trunc(number);
        let decimalPart = number - integerPart;
        return Math.abs(decimalPart);
    }

    function mapToHSL(value, min, max) {
        let normalizedValue = (value - min) / (max - min);
        normalizedValue = getDecimalPart(normalizedValue);
        let hue = normalizedValue * 360;
        return `hsl(${hue}, 100%, 50%)`;
    }

    function drawLine(y0, x0, y1, x1, plotFunc) {
        let dx = Math.abs(x1 - x0);
        let dy = Math.abs(y1 - y0);
        let sx = (x0 < x1) ? 1 : -1;
        let sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;
        while (true) {
            plotFunc(x0, y0); 
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x0 += sx;
            }
            if (e2 < dx) {
                err += dx;
                y0 += sy;
            }
        }
    }

    const keysPressed = {};
    document.addEventListener('keydown', (event) => { keysPressed[event.key] = true; });
    document.addEventListener('keyup', (event) => { keysPressed[event.key] = false; });
    function isKeyDown(key) { return keysPressed[key] || false; }
    function isAnyKeyDown() {
        for (let key in keysPressed) {
            if (keysPressed[key]) {
                return true;
            }
        }
        return false;
    }
    /*=== The Perlin Noise Class. Code generated by Sonnet. */
    class PerlinNoise {
        constructor() {
            // Permutation table
            this.p = new Array(256);
            for(let i = 0; i < 256; i++) {
                this.p[i] = i;
            }

            // Shuffle permutation table
            for(let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
            }

            // Extend the permutation table to avoid overflow
            this.p = [...this.p, ...this.p];
        }

        fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        lerp(t, a, b) {
            return a + t * (b - a);
        }

        grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        noise(x, y = 0, z = 0) {
            // Find unit cube that contains point
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;

            // Find relative x, y, z of point in cube
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);

            // Compute fade curves
            const u = this.fade(x);
            const v = this.fade(y);
            const w = this.fade(z);

            // Hash coordinates of cube corners
            const A = this.p[X] + Y;
            const AA = this.p[A] + Z;
            const AB = this.p[A + 1] + Z;
            const B = this.p[X + 1] + Y;
            const BA = this.p[B] + Z;
            const BB = this.p[B + 1] + Z;

            // Add blended results from corners of cube
            return this.lerp(w,
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA], x, y, z),
                        this.grad(this.p[BA], x-1, y, z)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB], x, y-1, z),
                        this.grad(this.p[BB], x-1, y-1, z)
                    )
                ),
                this.lerp(v,
                    this.lerp(u,
                        this.grad(this.p[AA+1], x, y, z-1),
                        this.grad(this.p[BA+1], x-1, y, z-1)
                    ),
                    this.lerp(u,
                        this.grad(this.p[AB+1], x, y-1, z-1),
                        this.grad(this.p[BB+1], x-1, y-1, z-1)
                    )
                )
            );
        }
    }

    /**
     *  ***************
     *    C o n O u t
     *  ***************
    */
    /**
     *    The ConsoleOut Class. Aimed to re-create the one I've written in C++
     *    with HTML capabilities. */
    class ConsoleOut {
        constructor(width, height, elementID) {
            this.defaultChar = ' ';
            this.w = width;
            this.h = height;
            this.conDiv = document.getElementById(elementID);
            this.conDiv.replaceChildren();
            this.lines = [];

            for (let i = 0; i < height; i++) {
                let newLineDiv = document.createElement('div');
                let firstSpan = document.createElement('span');
                let spaces = this.defaultChar.repeat(width);

                newLineDiv.id = 'Line ' + String(i);
                firstSpan.textContent = spaces;
                firstSpan.className = 'conOut-spn';
                newLineDiv.appendChild(firstSpan);

                this.conDiv.appendChild(newLineDiv);
                this.lines[i] = {
                    div: newLineDiv,
                    sections: [{ span: firstSpan, Xpoz: 0, length: this.w }]
                };
            }
        }

        __truncateSpan(sections, index, XCoord, trunLen) {
            const section = sections[index];
            const sectionStart = section.Xpoz;
            const sectionEnd = sectionStart + section.length;
            const truncStart = XCoord;
            const truncEnd = XCoord + trunLen;
            const parentDiv = section.span.parentElement;

            // Calculate overlap
            const overlapStart = Math.max(sectionStart, truncStart);
            const overlapEnd = Math.min(sectionEnd, truncEnd);
            const overlapLength = overlapEnd - overlapStart;

            // No overlap
            if (overlapLength <= 0) {
                return -1;
            }

            // Complete overlap: Remove the entire section
            if (overlapStart <= sectionStart && overlapEnd >= sectionEnd) {
                section.span.remove();
                sections.splice(index, 1);
                return 1;
            }

            // Overlap at the start: Truncate the beginning of the section
            if (overlapStart <= sectionStart) {
                const newStart = overlapEnd;
                const newLength = sectionEnd - newStart;
                section.Xpoz = newStart;
                section.length = newLength;
                section.span.textContent = section.span.textContent.slice(-newLength);
                return 2;
            }

            // Overlap at the end: Truncate the end of the section
            if (overlapEnd >= sectionEnd) {
                const newLength = overlapStart - sectionStart;
                section.length = newLength;
                section.span.textContent = section.span.textContent.substring(0, newLength);
                return 3;
            }

            // Overlap in the middle: Split the section into two
            const leftSpan = section.span.cloneNode(true);
            const rightSpan = section.span.cloneNode(true);

            const leftTextLength = overlapStart - sectionStart;
            const rightTextStart = overlapEnd - sectionStart;
            const rightTextLength = sectionEnd - overlapEnd;

            leftSpan.textContent = section.span.textContent.substring(0, leftTextLength);
            rightSpan.textContent = section.span.textContent.substring(rightTextStart);

            const leftSection = {
                span: leftSpan,
                Xpoz: sectionStart,
                length: leftTextLength
            };

            const rightSection = {
                span: rightSpan,
                Xpoz: overlapEnd,
                length: rightTextLength
            };

            // Replace the original section with the two new sections
            sections.splice(index, 1, leftSection, rightSection);

            // Update the DOM
            section.span.remove();
            parentDiv.insertBefore(rightSpan, parentDiv.children[index]);
            parentDiv.insertBefore(leftSpan, rightSpan);

            return 4;
        }

        _makeWay(YCoord, XCoord, emptyLength) {
            if (XCoord + emptyLength > this.w || XCoord < 0) { return -1; }
            let line = this.lines[YCoord];

            for (let i = line.sections.length - 1; i >= 0; i--) {
                this.__truncateSpan(line.sections, i, XCoord, emptyLength);
            }
            return 0;
        }

        _fitSpan(YCoord, XCoord, pendingSpan) {
            let line = this.lines[YCoord];
            let parentDiv = line.div;
            let spanLength = pendingSpan.textContent.length;
            pendingSpan.className = 'conOut-spn';

            let inserted = false;
            for (let i = 0; i < line.sections.length; i++) {
                let currentSection = line.sections[i];
                if (XCoord < currentSection.Xpoz) {
                    line.sections.splice(i, 0, {
                        span: pendingSpan,
                        Xpoz: XCoord,
                        length: spanLength
                    });
                    parentDiv.insertBefore(pendingSpan, currentSection.span);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                line.sections.push({
                    span: pendingSpan,
                    Xpoz: XCoord,
                    length: spanLength
                });
                parentDiv.appendChild(pendingSpan);
            }

            return 0;
        }

        _getConcernedSpanInfo(line, XCoord, length) {
            let info = [];
            const endCoord = XCoord + length;

            for (let section of line.sections) {
                const sectionEnd = section.Xpoz + section.length;
                if (XCoord >= sectionEnd || endCoord <= section.Xpoz) { continue; }
                const relStart = Math.max(0, XCoord - section.Xpoz);
                const relEnd = Math.min(section.length, endCoord - section.Xpoz);
                info.push({
                    span: section.span,
                    relStart: relStart,
                    relEnd: relEnd
                });
            }
            return info;
        }

        getRawText(YCoord, XCoord, length) {
            if (YCoord >= this.h || YCoord < 0 || XCoord < 0 || XCoord + length > this.w) { return ''; }
            let line = this.lines[YCoord];
            let concernedInfo = this._getConcernedSpanInfo(line, XCoord, length);
            let text = '';

            for (let currentInfo of concernedInfo) {
                let currentText = currentInfo.span.textContent;
                text += currentText.substring(currentInfo.relStart, currentInfo.relEnd);
            }
            return text;
        }

        setRawText(YCoord, XCoord, text) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            let line = this.lines[YCoord];
            let concernedInfo = this._getConcernedSpanInfo(line, XCoord, text.length);
            let i = 0;

            for (let currentInfo of concernedInfo) {
                let oriText = currentInfo.span.textContent;
                let textPart1 = oriText.substring(0, currentInfo.relStart);
                let newText = text.substring(i, i + currentInfo.relEnd - currentInfo.relStart);
                let textPart3 = oriText.substring(currentInfo.relEnd);
                currentInfo.span.textContent = textPart1 + newText + textPart3;
                i += currentInfo.relEnd - currentInfo.relStart;
            }
            return 0;
        }

        setRawTextMid(YCoord, XCoordMid, text) {
            this.setRawText(YCoord, XCoordMid - Math.floor(text.length / 2), text);
        }

        setStyle(YCoord, XCoord, length, emptyStyleSpan) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            let text = this.getRawText(YCoord, XCoord, length);
            let dupSpan = emptyStyleSpan.cloneNode(true);
            dupSpan.textContent = text;
            this._makeWay(YCoord, XCoord, length);
            this._fitSpan(YCoord, XCoord, dupSpan);
            return 0;
        }

        clearLineText(YCoord) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            this.setRawText(YCoord, 0, this.defaultChar.repeat(this.w));
            return 0;
        }

        clearLineStyle(YCoord) {
            if (YCoord >= this.h || YCoord < 0) { return 0; }
            let sp = document.createElement('span');
            sp.className = 'conOut-spn';
            this.setStyle(YCoord, 0, this.w, sp);
            return 0;
        }

        clsText() {
            for (let i = 0; i < this.h; i++) {
                this.clearLineText(i);
            }
            return 0;
        }

        clsStyle() {
            for (let i = 0; i < this.h; i++) {
                this.clearLineStyle(i);
            }
            return 0;
        }
    }


    /**
     *  ***********
     *    G A M E
     *  ***********
    */
    class Game {
        static Cars = {
            'Series 201' : {
                'name'          : '201-Kei',
                'maxPower'      : 625000.0,   // Watts
                'maxForce'      : 40000.0,    // Newtons
                'maxbrakeForce' : 40000.0,    // Newtons
                'weight'        : 35000.0,    // Kilograms
                'dragCoef'      : 55.0,       // N / (m/s)^2
                'fricCoef'      : 0.10,       // N / kg
                'centerOfMass'  : 1.0,        // Meters (Height)
                'length'        : 20.0        // Meters
            }
        }

        static Track = class Track {
            constructor() {
                this.myPerlin = new PerlinNoise();
                this.perlinY = Math.random();
                this.trains = Array();
            }

            getCurvature(distOffset) { return 0; } 

            registerTrain(train) { this.trains.push(train); }
        }

        static Train = class Train {
            constructor(car, carCount, track) {
                this.cars = Array(carCount).fill(car);
                this.throttle = 0;
                this.brake = 0;
                this.headings = 1; // Right; -1 for left.
                this.velocity = 0; // m/s

                this.throttleTarget = 0;
                this.brakeTarget = 0;

                this.totalMass = 0;
                this.largestDragCo = 0;
                this.avrFricCo = 0;
                this.avrCOM = 0;
                this.totalLen = 0;
                this.updateTotalStats();

                this.leftPoz = 0 - this.totalLen;
                this.rightPoz = 0;
                track.registerTrain(this);
            }

            applyThrottle(throttle) { this.throttleTarget = throttle; }

            applyBrake(brake) { if (this.brakeTarget == 0 && brake != 0) { this.throttleTarget = 0; } this.brakeTarget = brake; }

            offsetThrottle(throttle) { this.throttleTarget += throttle; }

            offsetBrake(brake) { if (this.brakeTarget == 0) { this.throttleTarget = 0; } this.brakeTarget += brake; }

            updateControls(deltaMS) { 
                if (this.throttleTarget > 1) { this.throttleTarget = 1; }
                if (this.throttleTarget < -1) { this.throttleTarget = -1; }
                if (this.brakeTarget > 1) { this.brakeTarget = 1; }
                if (this.brakeTarget < 0) { this.brakeTarget = 0; }
                let tSign = Math.sign(this.throttleTarget - this.throttle);
                let bSign = Math.sign(this.brakeTarget - this.brake);
                this.throttle += tSign * 0.33 * deltaMS / 1000;
                if (this.throttle * tSign >= this.throttleTarget * tSign) { this.throttle = this.throttleTarget; }
                this.brake += bSign * 0.33 * deltaMS / 1000;
                if (this.brake * bSign >= this.brakeTarget * bSign) { this.brake = this.brakeTarget; }
            }

            updateTotalStats() {
                for (let car of this.cars) {
                    this.totalMass += car.weight;
                    this.totalLen += car.length;
                    this.largestDragCo = Math.max(this.largestDragCo, car.dragCoef);
                    this.avrFricCo += car.fricCoef;
                    this.avrCOM += car.centerOfMass;
                }

                this.avrFricCo /= this.cars.length;
                this.avrCOM /= this.cars.length;
            }

            updatePhysics(deltaMS) {
                let dragForce = this.largestDragCo * this.velocity * this.velocity;
                let brakeForce = 0.0;
                let fwForce = 0.0;
                let fwDir = this.velocity === 0 ? Math.sign(this.throttle) : Math.sign(this.velocity) * Math.sign(this.throttle);
                let fricForce = 0.0;
                let brakeDir = this.velocity === 0 ? 0 : -1 * Math.sign(this.velocity);
                for (let car of this.cars) {
                    brakeForce += car['maxbrakeForce'] * this.brake;
                    let assumedPower = car['maxPower'] * Math.abs(this.throttle);
                    if (Math.abs(this.velocity) < 0.001) {
                        fwForce += this.throttle !== 0 ? car['maxForce'] : 0;
                    } else if (this.velocity * car['maxForce'] < assumedPower) {
                        fwForce += car['maxForce'];
                    } else {
                        fwForce += assumedPower / Math.abs(this.velocity);
                    }
                    fricForce += car['fricCoef'] * car['weight'];
                }
                let accel = (brakeDir * (dragForce + brakeForce + fricForce) + fwDir * (fwForce)) / this.totalMass;
                this.velocity += accel * deltaMS / 1000;
                this.leftPoz += this.velocity * deltaMS / 1000;
                this.rightPoz = this.leftPoz + this.totalLen;
            }

            swapHeading() {
                this.headings *= -1;
                this.throttle *= -1;
                this.throttleTarget *= -1;
            }

            appendCar(car) {
                if (this.headings === 1) { // Right
                    this.cars.unshift(car); this.leftPoz -= car['length'];
                } else { // Left
                    this.cars.push(car); this.rightPoz += car['length'];
                }
                // Calculate new velocity based on momentum
                let oldTotalMomentum = this.totalMass * this.velocity;

                // Update stats
                this.updateTotalStats();
                
                // Total momentum remains constant when adding a car
                this.velocity = oldTotalMomentum / this.totalMass;
            }

            removeCar() {
                if (this.cars.length <= 1) return; // Don't remove last car

                // Remove car based on heading direction
                if (this.headings === 1) { // Right heading
                    this.cars.pop(); // Remove from right end
                    this.rightPoz -= this.cars[this.cars.length - 1].length;
                } else { // Left heading
                    this.cars.shift(); // Remove from left end
                    this.leftPoz += this.cars[0].length;
                }

                this.updateTotalStats();
            }
        }

        constructor(conOut) {
            this.conOut = conOut;
            this.phyloopPeriod = 1000 / 240;      
            this.phyloopPerFrame = 2;
            this.beginMS = ms();
            this.lastPhyMS = this.beginMS;
            this.loopCounter = 0;
            this.breakOut = false;
            this.lastFrameTime = 0.0;
            this.realFrameTime = 0.0;

            this.myTrack = new Game.Track();
            this.myTrain = new Game.Train(Game.Cars['Series 201'], 6, this.myTrack);
            console.log('Game initialized.')
        }

        inputLoop() {
            if (isKeyDown('9')) { this.myTrain.offsetThrottle(-0.005); }
            if (isKeyDown('0')) { this.myTrain.offsetThrottle( 0.005); }
            if (isKeyDown('o')) { this.myTrain.offsetBrake(-0.005); }
            if (isKeyDown('p')) { this.myTrain.offsetBrake( 0.005); }
            if (isKeyDown(' ')) { this.breakOut = true; }
        }

        physicsLoop(deltaMS) {
            this.myTrain.updateControls(deltaMS);
            this.myTrain.updatePhysics(deltaMS);
        }

        renderLoop() {
            this.conOut.setRawText(2, 2, "Position (m)    : " + this.myTrain.rightPoz.toFixed(2) + "          ");
            this.conOut.setRawText(3, 2, "Velocity (kph)  : " + (this.myTrain.velocity * 3.6).toFixed(2) + "          ");
            this.conOut.setRawText(4, 2, "Throttle (%)    : " + (this.myTrain.throttle * 100).toFixed(2) + "          ");
            this.conOut.setRawText(5, 2, "Brake    (%)    : " + (this.myTrain.brake * 100).toFixed(2) + "          ");
            this.conOut.setRawText(7, 2, "Frame Time (ms) : " + (this.realFrameTime).toFixed(2) + "          ");
        }

        async gameLoop() {
            console.log('Gameloop started.')
            while (!this.breakOut) {
                this.inputLoop();
                let sleepTime = this.lastPhyMS + this.phyloopPeriod - ms();  
                if (sleepTime > 0) { await asyncSleep(sleepTime); }
                this.physicsLoop(ms() - this.lastPhyMS); this.lastPhyMS = ms();
                if (!(this.loopCounter % this.phyloopPerFrame)) { this.realFrameTime = ms() - this.lastFrameTime; this.renderLoop(); this.lastFrameTime = ms(); }
                this.loopCounter ++;
            }
        }
    }

    /**
     *  *********************
     *    T E S T I N G
     *  *********************
    */
    async function testDisplay(conOut) {
        let rawTexts = [' nothing', '.NOTHING'];
        let hintTexts = ['[Shift] + [SpaceBar] :  Next',
                         '                            '];
        let rI = 1;
        let showHint = 1;
        let blinkLastMS = ms();
        let hintI = 0;
        setTimeout(() => { showHint = 0; 
            conOut.setRawTextMid(HEIGHT - 10, WIDTH / 2, hintTexts[1]) }, 10000);
        outerLoop:
        for (let i = 0; i < HEIGHT; i = (i + 1) % HEIGHT) {
            for (let j = -10; j < WIDTH; j ++) {
                conOut.setRawText(i, j, rawTexts[rI]);   
                if (showHint) { 
                    if (blinkLastMS < ms() - 750) { 
                        blinkLastMS = ms();
                        conOut.setRawTextMid(HEIGHT - 10, WIDTH / 2, hintTexts[hintI]);
                        hintI = (hintI + 1) % 2;
                    }
                }
                await asyncSleep(1000 / 20);
                if (testBreakOut) { break outerLoop; }
            }
            if (i == HEIGHT - 1) { rI = (rI + 1) % 2;}
        }
        testBreakOut = 0;
        conOut.clsStyle();
        conOut.clsText();
        return 1;
    }

    async function testPerlin(conOut) {
        let p = new PerlinNoise();
        let DEPTH = 7;
        let xCenter = 0.0; let xZoom = 1.0;
        let yCenter = 0.0;
        let zCenter = 0.0; let zZoom = 1.0;
        let outZoom = 1.0;
        let sp = document.createElement('span');
        let dismissedHint = 0;
        var doDepthDisplay = false;
        let PKeyLast = isKeyDown('p');
        sp.style.backgroundColor = '#ffffff';
        sp.style.color = '#000000';
        function printXYZData() {
            conOut.setRawText(HEIGHT - 2, 4, `Z: ${zCenter.toFixed(3)}`);
            conOut.setRawText(HEIGHT - 3, 4, `Y: ${yCenter.toFixed(3)}`);
            conOut.setRawText(HEIGHT - 4, 4, `X: ${xCenter.toFixed(3)}`);
        }
        printXYZData();
        function drawPerlin(depth, plotFunc) {
            let points = [];
            for (let w = 0; w < WIDTH; w ++) {
                let x = xCenter + (w - WIDTH / 2) / WIDTH * xZoom;
                let z = zCenter + (depth - DEPTH / 2) / DEPTH * zZoom;
                let out = p.noise(x, yCenter, z) * outZoom * (HEIGHT / 2) + HEIGHT / 2;
                points.splice(0, 0, { Y: Math.floor(out), X: w });
            }
            for (let i = 0; i < points.length - 1; i ++) {
                drawLine(points[i].Y, points[i].X, points[i + 1].Y, points[i + 1].X, plotFunc);
            }
        }
        function charPlotFunc(X, Y) { conOut.setRawText(Y, X, '#'); }
        drawPerlin(DEPTH / 2, charPlotFunc);
        await asyncSleep(1000);
        let doDraw = 0;
        function pCheck(event) {
            if (event.key == 'p') {
                doDepthDisplay = !doDepthDisplay; conOut.clsStyle();
            }
        }
        document.addEventListener('keydown', pCheck);
        while (!testBreakOut) {
            doDraw = 0;
            if (isAnyKeyDown()) { doDraw = 1; }
            if (isKeyDown('m')) { dismissedHint = 1; }
            if (isKeyDown('a')) { xCenter -= 0.01 * xZoom; }
            if (isKeyDown('d')) { xCenter += 0.01 * xZoom;  }
            if (isKeyDown('s')) { zCenter -= 0.01 * zZoom;  }
            if (isKeyDown('w')) { zCenter += 0.01 * zZoom;  }
            if (isKeyDown('q')) { yCenter -= 0.01;  }
            if (isKeyDown('e')) { yCenter += 0.01;  }
            if (isKeyDown('h')) { xZoom /= 1.01; }
            if (isKeyDown('k')) { xZoom *= 1.01; }
            if (isKeyDown('u')) { zZoom /= 1.01; }
            if (isKeyDown('j')) { zZoom *= 1.01; }
            if (isKeyDown('y')) { outZoom /= 1.01; }
            if (isKeyDown('i')) { outZoom *= 1.01; }
            if (doDraw) {
                conOut.clsText();
                if (!dismissedHint) {
                    conOut.setRawText(HEIGHT - 4, WIDTH / 2 + 4, `WASDQE / UHJKYI / M / P / L`);
                }
                
                if (doDepthDisplay) {
                    conOut.clsStyle();
                    let sp = document.createElement('span');
                    for (let i = 0; i < DEPTH; i ++) {
                        sp.style.backgroundColor = mapToHSL(zCenter + (i - DEPTH / 2) / DEPTH * zZoom, -1, 1);
                        function stylePlotFunc(X, Y) { conOut.setStyle(Y, X, 1, sp); }
                        drawPerlin(i, stylePlotFunc);
                    }
                }
                
                drawPerlin(DEPTH / 2, charPlotFunc);
                printXYZData();
            }
            await asyncSleep(1000 / 60);
        }
        testBreakOut = 0;
        conOut.clsText();
        conOut.clsStyle();
        document.removeEventListener('keydown', pCheck);
        return 0;
    }
    
    document.body.innerHTML = '<div class="consoleOut-container" id="conOut-div0"></div>';
    /* V4refT5f's effort... Appreciate it! O_o
    document.body.innerHTML = '<div class="consoleOut-container" id="conOut-div0"></div>';
    document.addEventListener('keydown', function (event) {
        if (event.key == 'l') {
            document.getElementsByTagName('body')[0].classList.toggle('light-switch');
        }
        if (event.key == ' ' && event.shiftKey) {
            testBreakOut = 1;
        }
    })
    */

    document.addEventListener('keydown', function (event) {
        if ((event.key === 'l' || event.key === 'L')) {
            document.body.classList.toggle('light');
            if (document.body.classList.contains('light')) {
                window.lightMode = 'light-mode';
            }
            else {
                window.lightMode = 'dark-mode';
            }
            localStorage.setItem('window.lightMode', window.lightMode);
        }
        if (event.key == ' ' && event.shiftKey) {
            testBreakOut = 1;
        }
    });

    (function () {
        if (localStorage.getItem("window.lightMode") == "light-mode") {
            document.body.classList.add('light');
        }
    })();


    const WIDTH = 64;
    const HEIGHT = 64;
    const myConOut = new ConsoleOut(WIDTH, HEIGHT, 'conOut-div0');
    const myGame = new Game(myConOut);
    var testBreakOut = 0;



    
    if (isMobileDevice()) { 
        myConOut.setRawTextMid(Math.floor(HEIGHT / 2), Math.floor(WIDTH / 2), 'No Train For YiDong'); 
    } else {
        async function doTests() {
            await testDisplay(myConOut);
            await testPerlin(myConOut);
            console.log('Game about to begin.')
            await myGame.gameLoop(myConOut);
            return 0;
        }
        doTests();
    }
    


